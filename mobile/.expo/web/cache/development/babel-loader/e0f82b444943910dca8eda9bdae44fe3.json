{"ast":null,"code":"import { NativeModules } from 'react-native';\nimport { _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS } from '../AV';\nimport { isAudioEnabled, throwIfAudioIsDisabled } from './AudioAvailability';\nimport { Sound } from './Sound'; // TODO: consider changing these to enums\n\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT = 0;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP = 1;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4 = 2;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB = 3;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB = 4;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF = 5;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS = 6;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP = 7;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS = 8;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM = 9;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT = 0;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB = 1;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB = 2;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC = 3;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC = 4;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD = 5;\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM = 'lpcm';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3 = 'ac-3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3 = 'cac3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4 = 'ima4';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC = 'aac ';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP = 'celp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC = 'hvxc';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ = 'twvq';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3 = 'MAC3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6 = 'MAC6';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW = 'ulaw';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW = 'alaw';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN = 'QDMC';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2 = 'QDM2';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM = 'Qclp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1 = '.mp1';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2 = '.mp2';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3 = '.mp3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS = 'alac';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE = 'aach';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD = 'aacl';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD = 'aace';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR = 'aacf';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2 = 'aacg';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2 = 'aacp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL = 'aacs';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR = 'samr';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB = 'sawb';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE = 'AUDB';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC = 'ilbc';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA = 0x6d730011;\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM = 0x6d730031;\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3 = 'aes3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3 = 'ec-3';\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN = 0;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW = 0x20;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM = 0x40;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH = 0x60;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX = 0x7f;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT = 0;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE = 1;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED = 2;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE = 3; // TODO : maybe make presets for music and speech, or lossy / lossless.\n\nexport const RECORDING_OPTIONS_PRESET_HIGH_QUALITY = {\n  android: {\n    extension: '.m4a',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false\n  }\n};\nexport const RECORDING_OPTIONS_PRESET_LOW_QUALITY = {\n  android: {\n    extension: '.3gp',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false\n  }\n};\nlet _recorderExists = false;\nexport class Recording {\n  constructor() {\n    this._canRecord = false;\n    this._isDoneRecording = false;\n    this._finalDurationMillis = 0;\n    this._uri = null;\n    this._onRecordingStatusUpdate = null;\n    this._progressUpdateTimeoutVariable = null;\n    this._progressUpdateIntervalMillis = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n    this._options = null; // Internal methods\n\n    this._cleanupForUnloadedRecorder = async finalStatus => {\n      this._canRecord = false;\n      this._isDoneRecording = true; // $FlowFixMe(greg): durationMillis is not always defined\n\n      this._finalDurationMillis = finalStatus.durationMillis;\n      _recorderExists = false;\n\n      if (NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording) {\n        NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording(null);\n      }\n\n      this._disablePolling();\n\n      return await this.getStatusAsync(); // Automatically calls onRecordingStatusUpdate for the final state.\n    };\n\n    this._pollingLoop = async () => {\n      if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n        this._progressUpdateTimeoutVariable = setTimeout(this._pollingLoop, this._progressUpdateIntervalMillis);\n\n        try {\n          await this.getStatusAsync();\n        } catch (error) {\n          this._disablePolling();\n        }\n      }\n    }; // Note that all calls automatically call onRecordingStatusUpdate as a side effect.\n    // Get status API\n\n\n    this.getStatusAsync = async () => {\n      // Automatically calls onRecordingStatusUpdate.\n      if (this._canRecord) {\n        return this._performOperationAndHandleStatusAsync(() => NativeModules.ExponentAV.getAudioRecordingStatus());\n      }\n\n      const status = {\n        canRecord: false,\n        isRecording: false,\n        isDoneRecording: this._isDoneRecording,\n        durationMillis: this._finalDurationMillis\n      };\n\n      this._callOnRecordingStatusUpdateForNewStatus(status);\n\n      return status;\n    };\n  }\n\n  _disablePolling() {\n    if (this._progressUpdateTimeoutVariable != null) {\n      clearTimeout(this._progressUpdateTimeoutVariable);\n      this._progressUpdateTimeoutVariable = null;\n    }\n  }\n\n  _enablePollingIfNecessaryAndPossible() {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._disablePolling();\n\n      this._pollingLoop();\n    }\n  }\n\n  _callOnRecordingStatusUpdateForNewStatus(status) {\n    if (this._onRecordingStatusUpdate != null) {\n      this._onRecordingStatusUpdate(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(operation) {\n    throwIfAudioIsDisabled();\n\n    if (this._canRecord) {\n      const status = await operation();\n\n      this._callOnRecordingStatusUpdateForNewStatus(status);\n\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because this recorder is not ready to record.');\n    }\n  }\n\n  setOnRecordingStatusUpdate(onRecordingStatusUpdate) {\n    this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n\n    if (onRecordingStatusUpdate == null) {\n      this._disablePolling();\n    } else {\n      this._enablePollingIfNecessaryAndPossible();\n    }\n\n    this.getStatusAsync();\n  }\n\n  setProgressUpdateInterval(progressUpdateIntervalMillis) {\n    this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    this.getStatusAsync();\n  } // Record API\n\n\n  async prepareToRecordAsync(options = RECORDING_OPTIONS_PRESET_LOW_QUALITY) {\n    throwIfAudioIsDisabled();\n\n    if (_recorderExists) {\n      throw new Error('Only one Recording object can be prepared at a given time.');\n    }\n\n    if (this._isDoneRecording) {\n      throw new Error('This Recording object is done recording; you must make a new one.');\n    }\n\n    if (!options || !options.android || !options.ios) {\n      throw new Error('You must provide recording options for android and ios in order to prepare to record.');\n    }\n\n    const extensionRegex = /^\\.\\w+$/;\n\n    if (!options.android.extension || !options.ios.extension || !extensionRegex.test(options.android.extension) || !extensionRegex.test(options.ios.extension)) {\n      throw new Error(`Your file extensions must match ${extensionRegex.toString()}.`);\n    }\n\n    if (!this._canRecord) {\n      if (NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording) {\n        NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording(this._cleanupForUnloadedRecorder);\n      }\n\n      const {\n        uri,\n        status\n      } = await NativeModules.ExponentAV.prepareAudioRecorder(options);\n      _recorderExists = true;\n      this._uri = uri;\n      this._options = options;\n      this._canRecord = true;\n      const currentStatus = { ...status,\n        canRecord: true\n      };\n\n      this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n\n      this._enablePollingIfNecessaryAndPossible();\n\n      return currentStatus;\n    } else {\n      throw new Error('This Recording object is already prepared to record.');\n    }\n  }\n\n  async startAsync() {\n    return this._performOperationAndHandleStatusAsync(() => NativeModules.ExponentAV.startAudioRecording());\n  }\n\n  async pauseAsync() {\n    return this._performOperationAndHandleStatusAsync(() => NativeModules.ExponentAV.pauseAudioRecording());\n  }\n\n  async stopAndUnloadAsync() {\n    if (!this._canRecord) {\n      if (this._isDoneRecording) {\n        throw new Error('Cannot unload a Recording that has already been unloaded.');\n      } else {\n        throw new Error('Cannot unload a Recording that has not been prepared.');\n      }\n    } // We perform a separate native API call so that the state of the Recording can be updated with\n    // the final duration of the recording. (We cast stopStatus as Object to appease Flow)\n\n\n    const finalStatus = await NativeModules.ExponentAV.stopAudioRecording();\n    await NativeModules.ExponentAV.unloadAudioRecorder();\n    return this._cleanupForUnloadedRecorder(finalStatus);\n  } // Read API\n\n\n  getURI() {\n    return this._uri;\n  }\n\n  async createNewLoadedSound(initialStatus = {}, onPlaybackStatusUpdate = null) {\n    console.warn(`createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name`);\n    return this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate);\n  }\n\n  async createNewLoadedSoundAsync(initialStatus = {}, onPlaybackStatusUpdate = null) {\n    if (this._uri == null || !this._isDoneRecording) {\n      throw new Error('Cannot create sound when the Recording has not finished!');\n    }\n\n    return Sound.createAsync( // $FlowFixMe: Flow can't distinguish between this literal and Asset\n    {\n      uri: this._uri\n    }, initialStatus, onPlaybackStatusUpdate, false);\n  }\n\n}","map":{"version":3,"sources":["../../../src/av/Audio/Recording.ts"],"names":[],"mappings":"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","sourcesContent":["import { NativeModules } from 'react-native';\n\nimport {\n  _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  PlaybackStatus,\n  PlaybackStatusToSet,\n} from '../AV';\n\nimport { isAudioEnabled, throwIfAudioIsDisabled } from './AudioAvailability';\n\nimport { Sound } from './Sound';\n\nexport type RecordingOptions = {\n  android: {\n    extension: string;\n    outputFormat: number;\n    audioEncoder: number;\n    sampleRate?: number;\n    numberOfChannels?: number;\n    bitRate?: number;\n    maxFileSize?: number;\n  };\n  ios: {\n    extension: string;\n    outputFormat?: string | number;\n    audioQuality: number;\n    sampleRate: number;\n    numberOfChannels: number;\n    bitRate: number;\n    bitRateStrategy?: number;\n    bitDepthHint?: number;\n    linearPCMBitDepth?: number;\n    linearPCMIsBigEndian?: boolean;\n    linearPCMIsFloat?: boolean;\n  };\n};\n\n// TODO: consider changing these to enums\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT = 0;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP = 1;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4 = 2;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB = 3;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB = 4;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF = 5;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS = 6;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP = 7;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS = 8;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM = 9;\n\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT = 0;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB = 1;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB = 2;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC = 3;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC = 4;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD = 5;\n\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM = 'lpcm';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3 = 'ac-3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3 = 'cac3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4 = 'ima4';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC = 'aac ';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP = 'celp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC = 'hvxc';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ = 'twvq';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3 = 'MAC3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6 = 'MAC6';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW = 'ulaw';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW = 'alaw';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN = 'QDMC';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2 = 'QDM2';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM = 'Qclp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1 = '.mp1';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2 = '.mp2';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3 = '.mp3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS = 'alac';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE = 'aach';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD = 'aacl';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD = 'aace';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR = 'aacf';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2 = 'aacg';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2 = 'aacp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL = 'aacs';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR = 'samr';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB = 'sawb';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE = 'AUDB';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC = 'ilbc';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA = 0x6d730011;\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM = 0x6d730031;\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3 = 'aes3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3 = 'ec-3';\n\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN = 0;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW = 0x20;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM = 0x40;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH = 0x60;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX = 0x7f;\n\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT = 0;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE = 1;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED = 2;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE = 3;\n\n// TODO : maybe make presets for music and speech, or lossy / lossless.\n\nexport const RECORDING_OPTIONS_PRESET_HIGH_QUALITY: RecordingOptions = {\n  android: {\n    extension: '.m4a',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false,\n  },\n};\n\nexport const RECORDING_OPTIONS_PRESET_LOW_QUALITY: RecordingOptions = {\n  android: {\n    extension: '.3gp',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false,\n  },\n};\n\n// TODO: For consistency with PlaybackStatus, should we include progressUpdateIntervalMillis here as\n// well?\nexport type RecordingStatus = {\n  canRecord: boolean;\n  isRecording: boolean;\n  isDoneRecording: boolean;\n  durationMillis: number;\n};\n\nlet _recorderExists: boolean = false;\n\nexport class Recording {\n  _canRecord: boolean = false;\n  _isDoneRecording: boolean = false;\n  _finalDurationMillis: number = 0;\n  _uri: string | null = null;\n  _onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null;\n  _progressUpdateTimeoutVariable: number | null = null;\n  _progressUpdateIntervalMillis: number = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n  _options: RecordingOptions | null = null;\n\n  // Internal methods\n\n  _cleanupForUnloadedRecorder = async (finalStatus: RecordingStatus) => {\n    this._canRecord = false;\n    this._isDoneRecording = true;\n    // $FlowFixMe(greg): durationMillis is not always defined\n    this._finalDurationMillis = finalStatus.durationMillis;\n    _recorderExists = false;\n    if (NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording) {\n      NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording(null);\n    }\n    this._disablePolling();\n    return await this.getStatusAsync(); // Automatically calls onRecordingStatusUpdate for the final state.\n  };\n\n  _pollingLoop = async () => {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._progressUpdateTimeoutVariable = setTimeout(\n        this._pollingLoop,\n        this._progressUpdateIntervalMillis\n      );\n      try {\n        await this.getStatusAsync();\n      } catch (error) {\n        this._disablePolling();\n      }\n    }\n  };\n\n  _disablePolling() {\n    if (this._progressUpdateTimeoutVariable != null) {\n      clearTimeout(this._progressUpdateTimeoutVariable);\n      this._progressUpdateTimeoutVariable = null;\n    }\n  }\n\n  _enablePollingIfNecessaryAndPossible() {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._disablePolling();\n      this._pollingLoop();\n    }\n  }\n\n  _callOnRecordingStatusUpdateForNewStatus(status: RecordingStatus) {\n    if (this._onRecordingStatusUpdate != null) {\n      this._onRecordingStatusUpdate(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<RecordingStatus>\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n    if (this._canRecord) {\n      const status = await operation();\n      this._callOnRecordingStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because this recorder is not ready to record.');\n    }\n  }\n\n  // Note that all calls automatically call onRecordingStatusUpdate as a side effect.\n\n  // Get status API\n\n  getStatusAsync = async (): Promise<RecordingStatus> => {\n    // Automatically calls onRecordingStatusUpdate.\n    if (this._canRecord) {\n      return this._performOperationAndHandleStatusAsync(() =>\n        NativeModules.ExponentAV.getAudioRecordingStatus()\n      );\n    }\n    const status = {\n      canRecord: false,\n      isRecording: false,\n      isDoneRecording: this._isDoneRecording,\n      durationMillis: this._finalDurationMillis,\n    };\n    this._callOnRecordingStatusUpdateForNewStatus(status);\n    return status;\n  };\n\n  setOnRecordingStatusUpdate(onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null) {\n    this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n    if (onRecordingStatusUpdate == null) {\n      this._disablePolling();\n    } else {\n      this._enablePollingIfNecessaryAndPossible();\n    }\n    this.getStatusAsync();\n  }\n\n  setProgressUpdateInterval(progressUpdateIntervalMillis: number) {\n    this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    this.getStatusAsync();\n  }\n\n  // Record API\n\n  async prepareToRecordAsync(\n    options: RecordingOptions = RECORDING_OPTIONS_PRESET_LOW_QUALITY\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n\n    if (_recorderExists) {\n      throw new Error('Only one Recording object can be prepared at a given time.');\n    }\n\n    if (this._isDoneRecording) {\n      throw new Error('This Recording object is done recording; you must make a new one.');\n    }\n\n    if (!options || !options.android || !options.ios) {\n      throw new Error(\n        'You must provide recording options for android and ios in order to prepare to record.'\n      );\n    }\n\n    const extensionRegex = /^\\.\\w+$/;\n    if (\n      !options.android.extension ||\n      !options.ios.extension ||\n      !extensionRegex.test(options.android.extension) ||\n      !extensionRegex.test(options.ios.extension)\n    ) {\n      throw new Error(`Your file extensions must match ${extensionRegex.toString()}.`);\n    }\n\n    if (!this._canRecord) {\n      if (NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording) {\n        NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording(\n          this._cleanupForUnloadedRecorder\n        );\n      }\n\n      const {\n        uri,\n        status,\n      }: {\n        uri: string;\n        // status is of type RecordingStatus, but without the canRecord field populated\n        status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n      } = await NativeModules.ExponentAV.prepareAudioRecorder(options);\n\n      _recorderExists = true;\n      this._uri = uri;\n      this._options = options;\n      this._canRecord = true;\n\n      const currentStatus = { ...status, canRecord: true };\n      this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n      this._enablePollingIfNecessaryAndPossible();\n      return currentStatus;\n    } else {\n      throw new Error('This Recording object is already prepared to record.');\n    }\n  }\n\n  async startAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() =>\n      NativeModules.ExponentAV.startAudioRecording()\n    );\n  }\n\n  async pauseAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() =>\n      NativeModules.ExponentAV.pauseAudioRecording()\n    );\n  }\n\n  async stopAndUnloadAsync(): Promise<RecordingStatus> {\n    if (!this._canRecord) {\n      if (this._isDoneRecording) {\n        throw new Error('Cannot unload a Recording that has already been unloaded.');\n      } else {\n        throw new Error('Cannot unload a Recording that has not been prepared.');\n      }\n    }\n    // We perform a separate native API call so that the state of the Recording can be updated with\n    // the final duration of the recording. (We cast stopStatus as Object to appease Flow)\n    const finalStatus = await NativeModules.ExponentAV.stopAudioRecording();\n    await NativeModules.ExponentAV.unloadAudioRecorder();\n    return this._cleanupForUnloadedRecorder(finalStatus);\n  }\n\n  // Read API\n\n  getURI(): string | null {\n    return this._uri;\n  }\n\n  async createNewLoadedSound(\n    initialStatus: PlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: PlaybackStatus) => void) | null = null\n  ): Promise<{ sound: Sound; status: PlaybackStatus }> {\n    console.warn(\n      `createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name`\n    );\n    return this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate);\n  }\n\n  async createNewLoadedSoundAsync(\n    initialStatus: PlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: PlaybackStatus) => void) | null = null\n  ): Promise<{ sound: Sound; status: PlaybackStatus }> {\n    if (this._uri == null || !this._isDoneRecording) {\n      throw new Error('Cannot create sound when the Recording has not finished!');\n    }\n    return Sound.createAsync(\n      // $FlowFixMe: Flow can't distinguish between this literal and Asset\n      { uri: this._uri },\n      initialStatus,\n      onPlaybackStatusUpdate,\n      false\n    );\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}