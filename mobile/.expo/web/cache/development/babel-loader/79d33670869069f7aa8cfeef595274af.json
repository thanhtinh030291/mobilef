{"ast":null,"code":"import { Constants } from 'expo-constants';\nimport prettyFormat from 'pretty-format';\nimport parseErrorStack from 'react-native/Libraries/Core/Devtools/parseErrorStack';\nimport symbolicateStackTrace from 'react-native/Libraries/Core/Devtools/symbolicateStackTrace';\nexport const EXPO_CONSOLE_METHOD_NAME = '__expoConsoleLog';\n\nasync function serializeLogDataAsync(data, level) {\n  let serializedValues;\n  let includesStack = false;\n\n  if (_stackTraceLogsSupported()) {\n    if (_isUnhandledPromiseRejection(data, level)) {\n      let rawStack = data[0];\n      let syntheticError = {\n        stack: rawStack\n      };\n      let stack = await _symbolicateErrorAsync(syntheticError);\n\n      if (!stack.length) {\n        serializedValues = _stringifyLogData(data);\n      } else {\n        // NOTE: This doesn't handle error messages with newlines\n        let errorMessage = rawStack.split('\\n')[1];\n        serializedValues = [{\n          message: `[Unhandled promise rejection: ${errorMessage}]`,\n          stack: _formatStack(stack)\n        }];\n        includesStack = true;\n      }\n    } else if (data.length === 1 && data[0] instanceof Error) {\n      // When there's only one argument to the log function and that argument is an error, we\n      // include the error's stack. If there's more than one argument then we don't include the\n      // stack because it's not easy to display nicely in our current UI.\n      let serializedError = await _serializeErrorAsync(data[0]);\n      serializedValues = [serializedError];\n      includesStack = serializedError.hasOwnProperty('stack');\n    } else if (level === 'warn' || level === 'error') {\n      // For console.warn and console.error it is usually useful to know the stack that leads to the\n      // warning or error, so we provide this information to help out with debugging\n      let error = _captureConsoleStackTrace(); // [\"hello\", \"world\"] becomes \"hello, world\"\n\n\n      let errorMessage = _stringifyLogData(data).join(', ');\n\n      let serializedError = await _serializeErrorAsync(error, errorMessage);\n      serializedValues = [serializedError];\n      includesStack = serializedError.hasOwnProperty('stack');\n    } else {\n      serializedValues = _stringifyLogData(data);\n    }\n  } else {\n    serializedValues = _stringifyLogData(data);\n  }\n\n  return {\n    body: [...serializedValues],\n    includesStack\n  };\n}\n\nfunction _stringifyLogData(data) {\n  return data.map(item => {\n    if (typeof item === 'string') {\n      return item;\n    } else {\n      return prettyFormat(item);\n    }\n  });\n}\n\nasync function _serializeErrorAsync(error, message) {\n  if (message == null) {\n    message = error.message;\n  }\n\n  if (!error.stack || !error.stack.length) {\n    return prettyFormat(error);\n  }\n\n  let stack = await _symbolicateErrorAsync(error);\n\n  let formattedStack = _formatStack(stack);\n\n  return {\n    message,\n    stack: formattedStack\n  };\n}\n\nasync function _symbolicateErrorAsync(error) {\n  let parsedStack = parseErrorStack(error);\n  let symbolicatedStack;\n\n  try {\n    symbolicatedStack = await symbolicateStackTrace(parsedStack);\n  } catch (error) {\n    return parsedStack;\n  } // In this context an unsymbolicated stack is better than no stack\n\n\n  if (!symbolicatedStack) {\n    return parsedStack;\n  } // Clean the stack trace\n\n\n  return symbolicatedStack.map(_removeProjectRoot);\n}\n\nfunction _formatStack(stack) {\n  return stack.map(frame => {\n    let line = `${frame.file}:${frame.lineNumber}`;\n\n    if (frame.column != null) {\n      line += `:${frame.column}`;\n    }\n\n    line += ` in ${frame.methodName}`;\n    return line;\n  }).join('\\n');\n}\n\nfunction _removeProjectRoot(frame) {\n  let filename = frame.file;\n\n  if (filename == null) {\n    return frame;\n  }\n\n  let projectRoot = _getProjectRoot();\n\n  if (projectRoot == null) {\n    return frame;\n  }\n\n  if (filename.startsWith(projectRoot)) {\n    filename = filename.substring(projectRoot.length);\n\n    if (filename[0] === '/' || filename[0] === '\\\\') {\n      filename = filename.substring(1);\n    }\n\n    frame.file = filename;\n  }\n\n  return frame;\n}\n/**\n * Returns whether the development server that served this project supports logs with a stack trace.\n * Specifically, the version of Expo CLI that includes `projectRoot` in the manifest also accepts\n * payloads of the form:\n *\n * {\n *   includesStack: boolean, body: [{ message: string, stack: string }],\n * }\n */\n\n\nfunction _stackTraceLogsSupported() {\n  return !!(__DEV__ && _getProjectRoot());\n}\n\nfunction _isUnhandledPromiseRejection(data, level) {\n  return level === 'warn' && typeof data[0] === 'string' && /^Possible Unhandled Promise Rejection/.test(data[0]);\n}\n\nfunction _captureConsoleStackTrace() {\n  try {\n    throw new Error();\n  } catch (error) {\n    let stackLines = error.stack.split('\\n');\n    let consoleMethodIndex = stackLines.findIndex(frame => frame.includes(EXPO_CONSOLE_METHOD_NAME));\n\n    if (consoleMethodIndex !== -1) {\n      stackLines = stackLines.slice(consoleMethodIndex + 1);\n      error.stack = stackLines.join('\\n');\n    }\n\n    return error;\n  }\n}\n\nfunction _getProjectRoot() {\n  return Constants.manifest && Constants.manifest.developer ? Constants.manifest.developer.projectRoot : null;\n}\n\nexport default {\n  serializeLogDataAsync\n};","map":{"version":3,"sources":["../../src/logs/LogSerialization.ts"],"names":[],"mappings":"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","sourcesContent":["import { Constants } from 'expo-constants';\nimport prettyFormat from 'pretty-format';\nimport parseErrorStack, { StackFrame } from 'react-native/Libraries/Core/Devtools/parseErrorStack';\nimport symbolicateStackTrace from 'react-native/Libraries/Core/Devtools/symbolicateStackTrace';\n\nimport { LogData, LogLevel } from './RemoteLogging';\n\ntype SerializedData = {\n  body: LogData[];\n  includesStack: boolean;\n};\n\nexport const EXPO_CONSOLE_METHOD_NAME = '__expoConsoleLog';\n\nasync function serializeLogDataAsync(data: unknown[], level: LogLevel): Promise<SerializedData> {\n  let serializedValues: ReadonlyArray<LogData>;\n  let includesStack = false;\n\n  if (_stackTraceLogsSupported()) {\n    if (_isUnhandledPromiseRejection(data, level)) {\n      let rawStack = data[0] as string;\n      let syntheticError = { stack: rawStack };\n      let stack = await _symbolicateErrorAsync(syntheticError as Error);\n\n      if (!stack.length) {\n        serializedValues = _stringifyLogData(data);\n      } else {\n        // NOTE: This doesn't handle error messages with newlines\n        let errorMessage = rawStack.split('\\n')[1];\n        serializedValues = [\n          {\n            message: `[Unhandled promise rejection: ${errorMessage}]`,\n            stack: _formatStack(stack),\n          },\n        ];\n        includesStack = true;\n      }\n    } else if (data.length === 1 && data[0] instanceof Error) {\n      // When there's only one argument to the log function and that argument is an error, we\n      // include the error's stack. If there's more than one argument then we don't include the\n      // stack because it's not easy to display nicely in our current UI.\n\n      let serializedError = await _serializeErrorAsync(data[0] as Error);\n      serializedValues = [serializedError];\n      includesStack = serializedError.hasOwnProperty('stack');\n    } else if (level === 'warn' || level === 'error') {\n      // For console.warn and console.error it is usually useful to know the stack that leads to the\n      // warning or error, so we provide this information to help out with debugging\n\n      let error = _captureConsoleStackTrace();\n      // [\"hello\", \"world\"] becomes \"hello, world\"\n      let errorMessage = _stringifyLogData(data).join(', ');\n\n      let serializedError = await _serializeErrorAsync(error, errorMessage);\n      serializedValues = [serializedError];\n      includesStack = serializedError.hasOwnProperty('stack');\n    } else {\n      serializedValues = _stringifyLogData(data);\n    }\n  } else {\n    serializedValues = _stringifyLogData(data);\n  }\n\n  return {\n    body: [...serializedValues],\n    includesStack,\n  };\n}\n\nfunction _stringifyLogData(data: unknown[]): string[] {\n  return data.map(item => {\n    if (typeof item === 'string') {\n      return item;\n    } else {\n      return prettyFormat(item);\n    }\n  });\n}\n\nasync function _serializeErrorAsync(error: Error, message?: string): Promise<LogData> {\n  if (message == null) {\n    message = error.message;\n  }\n\n  if (!error.stack || !error.stack.length) {\n    return prettyFormat(error);\n  }\n\n  let stack = await _symbolicateErrorAsync(error);\n  let formattedStack = _formatStack(stack);\n\n  return { message, stack: formattedStack };\n}\n\nasync function _symbolicateErrorAsync(error: Error): Promise<StackFrame[]> {\n  let parsedStack = parseErrorStack(error);\n  let symbolicatedStack: StackFrame[] | null;\n  try {\n    symbolicatedStack = await symbolicateStackTrace(parsedStack);\n  } catch (error) {\n    return parsedStack;\n  }\n\n  // In this context an unsymbolicated stack is better than no stack\n  if (!symbolicatedStack) {\n    return parsedStack;\n  }\n\n  // Clean the stack trace\n  return symbolicatedStack.map(_removeProjectRoot);\n}\n\nfunction _formatStack(stack: StackFrame[]): string {\n  return stack\n    .map(frame => {\n      let line = `${frame.file}:${frame.lineNumber}`;\n      if (frame.column != null) {\n        line += `:${frame.column}`;\n      }\n      line += ` in ${frame.methodName}`;\n      return line;\n    })\n    .join('\\n');\n}\n\nfunction _removeProjectRoot(frame: StackFrame): StackFrame {\n  let filename = frame.file;\n  if (filename == null) {\n    return frame;\n  }\n\n  let projectRoot = _getProjectRoot();\n  if (projectRoot == null) {\n    return frame;\n  }\n\n  if (filename.startsWith(projectRoot)) {\n    filename = filename.substring(projectRoot.length);\n    if (filename[0] === '/' || filename[0] === '\\\\') {\n      filename = filename.substring(1);\n    }\n    frame.file = filename;\n  }\n\n  return frame;\n}\n\n/**\n * Returns whether the development server that served this project supports logs with a stack trace.\n * Specifically, the version of Expo CLI that includes `projectRoot` in the manifest also accepts\n * payloads of the form:\n *\n * {\n *   includesStack: boolean, body: [{ message: string, stack: string }],\n * }\n */\nfunction _stackTraceLogsSupported(): boolean {\n  return !!(__DEV__ && _getProjectRoot());\n}\n\nfunction _isUnhandledPromiseRejection(data: unknown[], level: LogLevel): boolean {\n  return (\n    level === 'warn' &&\n    typeof data[0] === 'string' &&\n    /^Possible Unhandled Promise Rejection/.test(data[0] as string)\n  );\n}\n\nfunction _captureConsoleStackTrace(): Error {\n  try {\n    throw new Error();\n  } catch (error) {\n    let stackLines = error.stack.split('\\n');\n    let consoleMethodIndex = stackLines.findIndex(frame =>\n      frame.includes(EXPO_CONSOLE_METHOD_NAME)\n    );\n    if (consoleMethodIndex !== -1) {\n      stackLines = stackLines.slice(consoleMethodIndex + 1);\n      error.stack = stackLines.join('\\n');\n    }\n    return error;\n  }\n}\n\nfunction _getProjectRoot(): string | null {\n  return Constants.manifest && Constants.manifest.developer\n    ? Constants.manifest.developer.projectRoot\n    : null;\n}\n\nexport default {\n  serializeLogDataAsync,\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}