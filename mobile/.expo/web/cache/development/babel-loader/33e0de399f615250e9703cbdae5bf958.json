{"ast":null,"code":"import { Constants } from 'expo-constants';\nimport { EventEmitter } from 'fbemitter';\nimport invariant from 'invariant';\nimport UUID from 'uuid-js';\nimport LogSerialization from './LogSerialization';\n\nconst _sessionId = UUID.create().toString();\n\nconst _logQueue = [];\n\nconst _transportEventEmitter = new EventEmitter();\n\nlet _logCounter = 0;\nlet _isSendingLogs = false;\nlet _completionPromise = null;\nlet _resolveCompletion = null;\n\nasync function enqueueRemoteLogAsync(level, additionalFields, data) {\n  if (_isReactNativeWarning(data)) {\n    // Remove the stack trace from the warning message since we'll capture our own\n    if (data.length === 0) {\n      throw new Error(`Warnings must include log arguments`);\n    }\n\n    const warning = data[0];\n\n    if (typeof warning !== 'string') {\n      throw new TypeError(`The log argument for a warning must be a string`);\n    }\n\n    const lines = warning.split('\\n');\n\n    if (lines.length > 1 && /^\\s+in /.test(lines[1])) {\n      data[0] = lines[0];\n    }\n  }\n\n  let {\n    body,\n    includesStack\n  } = await LogSerialization.serializeLogDataAsync(data, level);\n\n  _logQueue.push({\n    count: _logCounter++,\n    level,\n    body,\n    includesStack,\n    ...additionalFields\n  }); // Send the logs asynchronously (system errors are emitted with transport error events) and throw an uncaught error\n\n\n  _sendRemoteLogsAsync().catch(error => {\n    setImmediate(() => {\n      throw error;\n    });\n  });\n}\n\nasync function _sendRemoteLogsAsync() {\n  if (_isSendingLogs || !_logQueue.length) {\n    return;\n  } // Our current transport policy is to send all of the pending log messages in one batch. If we opt\n  // for another policy (ex: throttling) this is where to to implement it.\n\n\n  let batch = _logQueue.splice(0);\n\n  let {\n    logUrl\n  } = Constants.manifest;\n  invariant(typeof logUrl === 'string', 'The Expo project manifest must specify `logUrl`');\n  _isSendingLogs = true;\n\n  try {\n    await _sendNextLogBatchAsync(batch, logUrl);\n  } finally {\n    _isSendingLogs = false;\n  }\n\n  if (_logQueue.length) {\n    return _sendRemoteLogsAsync();\n  } else if (_resolveCompletion) {\n    _resolveCompletion();\n  }\n}\n\nasync function _sendNextLogBatchAsync(batch, logUrl) {\n  let response;\n\n  try {\n    response = await fetch(logUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Connection: 'keep-alive',\n        'Proxy-Connection': 'keep-alive',\n        Accept: 'application/json',\n        'Device-Id': Constants.installationId,\n        'Device-Name': Constants.deviceName,\n        'Session-Id': _sessionId\n      },\n      body: JSON.stringify(batch)\n    });\n  } catch (error) {\n    _transportEventEmitter.emit('error', {\n      error\n    });\n\n    return;\n  }\n\n  let success = response.status >= 200 && response.status < 300;\n\n  if (!success) {\n    _transportEventEmitter.emit('error', {\n      error: new Error(`An HTTP error occurred when sending remote logs`),\n      response\n    });\n  }\n}\n\nfunction addTransportErrorListener(listener) {\n  return _transportEventEmitter.addListener('error', listener);\n}\n\nfunction _isReactNativeWarning(data) {\n  // NOTE: RN does the same thing internally for YellowBox\n  let message = data[0];\n  return data.length === 1 && typeof message === 'string' && message.startsWith('Warning: ');\n}\n\nexport default {\n  enqueueRemoteLogAsync,\n  addTransportErrorListener\n};\n/**\n * Returns a promise that resolves when all entries in the log queue have been sent. This method is\n * intended for testing only.\n */\n\nexport function __waitForEmptyLogQueueAsync() {\n  if (_completionPromise) {\n    return _completionPromise;\n  }\n\n  if (!_isSendingLogs && !_logQueue.length) {\n    return Promise.resolve();\n  }\n\n  _completionPromise = new Promise(resolve => {\n    _resolveCompletion = () => {\n      invariant(!_isSendingLogs, `Must not be sending logs at completion`);\n      invariant(!_logQueue.length, `Log queue must be empty at completion`);\n      _completionPromise = null;\n      _resolveCompletion = null;\n      resolve();\n    };\n  });\n  return _completionPromise;\n}","map":{"version":3,"sources":["../../src/logs/RemoteLogging.ts"],"names":[],"mappings":"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","sourcesContent":["import { Constants } from 'expo-constants';\nimport { EventEmitter, EventSubscription } from 'fbemitter';\nimport invariant from 'invariant';\nimport UUID from 'uuid-js';\n\nimport LogSerialization from './LogSerialization';\n\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\ntype LogEntry = {\n  count: number;\n  level: LogLevel;\n  body: LogData[];\n  includesStack: boolean;\n  groupDepth?: number;\n} & LogEntryFields;\n\nexport type LogEntryFields = {\n  shouldHide?: boolean;\n  groupDepth?: number;\n  groupCollapsed?: boolean;\n};\n\nexport type LogData = string | LogErrorData;\nexport type LogErrorData = { message: string; stack: string };\n\ntype TransportErrorListener = (event: { error: Error; response?: Response }) => void;\n\nconst _sessionId = UUID.create().toString();\nconst _logQueue: LogEntry[] = [];\nconst _transportEventEmitter = new EventEmitter();\n\nlet _logCounter = 0;\nlet _isSendingLogs = false;\nlet _completionPromise: Promise<void> | null = null;\nlet _resolveCompletion: (() => void) | null = null;\n\nasync function enqueueRemoteLogAsync(\n  level: LogLevel,\n  additionalFields: LogEntryFields,\n  data: unknown[]\n): Promise<void> {\n  if (_isReactNativeWarning(data)) {\n    // Remove the stack trace from the warning message since we'll capture our own\n    if (data.length === 0) {\n      throw new Error(`Warnings must include log arguments`);\n    }\n    const warning = data[0];\n    if (typeof warning !== 'string') {\n      throw new TypeError(`The log argument for a warning must be a string`);\n    }\n    const lines = warning.split('\\n');\n    if (lines.length > 1 && /^\\s+in /.test(lines[1])) {\n      data[0] = lines[0];\n    }\n  }\n\n  let { body, includesStack } = await LogSerialization.serializeLogDataAsync(data, level);\n\n  _logQueue.push({\n    count: _logCounter++,\n    level,\n    body,\n    includesStack,\n    ...additionalFields,\n  });\n\n  // Send the logs asynchronously (system errors are emitted with transport error events) and throw an uncaught error\n  _sendRemoteLogsAsync().catch(error => {\n    setImmediate(() => {\n      throw error;\n    });\n  });\n}\n\nasync function _sendRemoteLogsAsync(): Promise<void> {\n  if (_isSendingLogs || !_logQueue.length) {\n    return;\n  }\n\n  // Our current transport policy is to send all of the pending log messages in one batch. If we opt\n  // for another policy (ex: throttling) this is where to to implement it.\n  let batch = _logQueue.splice(0);\n\n  let { logUrl } = Constants.manifest;\n  invariant(typeof logUrl === 'string', 'The Expo project manifest must specify `logUrl`');\n\n  _isSendingLogs = true;\n  try {\n    await _sendNextLogBatchAsync(batch, logUrl);\n  } finally {\n    _isSendingLogs = false;\n  }\n\n  if (_logQueue.length) {\n    return _sendRemoteLogsAsync();\n  } else if (_resolveCompletion) {\n    _resolveCompletion();\n  }\n}\n\nasync function _sendNextLogBatchAsync(batch: LogEntry[], logUrl: string): Promise<void> {\n  let response;\n  try {\n    response = await fetch(logUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Connection: 'keep-alive',\n        'Proxy-Connection': 'keep-alive',\n        Accept: 'application/json',\n        'Device-Id': Constants.installationId,\n        'Device-Name': Constants.deviceName,\n        'Session-Id': _sessionId,\n      },\n      body: JSON.stringify(batch),\n    });\n  } catch (error) {\n    _transportEventEmitter.emit('error', { error });\n    return;\n  }\n\n  let success = response.status >= 200 && response.status < 300;\n  if (!success) {\n    _transportEventEmitter.emit('error', {\n      error: new Error(`An HTTP error occurred when sending remote logs`),\n      response,\n    });\n  }\n}\n\nfunction addTransportErrorListener(listener: TransportErrorListener): EventSubscription {\n  return _transportEventEmitter.addListener('error', listener);\n}\n\nfunction _isReactNativeWarning(data: unknown[]): boolean {\n  // NOTE: RN does the same thing internally for YellowBox\n  let message = data[0];\n  return data.length === 1 && typeof message === 'string' && message.startsWith('Warning: ');\n}\n\nexport default {\n  enqueueRemoteLogAsync,\n  addTransportErrorListener,\n};\n\n/**\n * Returns a promise that resolves when all entries in the log queue have been sent. This method is\n * intended for testing only.\n */\nexport function __waitForEmptyLogQueueAsync(): Promise<void> {\n  if (_completionPromise) {\n    return _completionPromise;\n  }\n\n  if (!_isSendingLogs && !_logQueue.length) {\n    return Promise.resolve();\n  }\n\n  _completionPromise = new Promise(resolve => {\n    _resolveCompletion = () => {\n      invariant(!_isSendingLogs, `Must not be sending logs at completion`);\n      invariant(!_logQueue.length, `Log queue must be empty at completion`);\n\n      _completionPromise = null;\n      _resolveCompletion = null;\n\n      resolve();\n    };\n  });\n  return _completionPromise;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}