{"ast":null,"code":"import { NativeModules } from 'react-native';\nconst NativeProxy = NativeModules.ExpoNativeModuleProxy;\nconst modulesConstantsKey = \"modulesConstants\";\nconst exportedMethodsKey = \"exportedMethods\";\nconst NativeModulesProxy = {};\n\nif (NativeProxy) {\n  Object.keys(NativeProxy[exportedMethodsKey]).forEach(moduleName => {\n    NativeModulesProxy[moduleName] = NativeProxy[modulesConstantsKey][moduleName] || {};\n    NativeProxy[exportedMethodsKey][moduleName].forEach(methodInfo => {\n      NativeModulesProxy[moduleName][methodInfo.name] = async (...args) => {\n        const {\n          key,\n          argumentsCount\n        } = methodInfo;\n\n        if (argumentsCount !== args.length) {\n          throw new Error(`Arguments count mismatch, ${args.length} provided, ${argumentsCount} have been expected.`);\n        }\n\n        return await NativeProxy.callMethod(moduleName, key, args);\n      };\n    }); // These are called by EventEmitter (which is a wrapper for NativeEventEmitter)\n    // only on iOS and they use iOS-specific native module, EXReactNativeEventEmitter.\n    //\n    // On Android only {start,stop}Observing are called on the native module\n    // and these should be exported as Expo methods.\n\n    NativeModulesProxy[moduleName].addListener = (...args) => NativeModules.EXReactNativeEventEmitter.addProxiedListener(moduleName, ...args);\n\n    NativeModulesProxy[moduleName].removeListeners = (...args) => NativeModules.EXReactNativeEventEmitter.removeProxiedListeners(moduleName, ...args);\n  });\n} else {\n  console.warn(\"No native NativeModulesProxy found among NativeModules, are you sure the expo-react-native-adapter's modules are linked properly?\");\n}\n\nmodule.exports = NativeModulesProxy;","map":{"version":3,"sources":["C:/xampp/htdocs/app/mobile/node_modules/expo-react-native-adapter/src/NativeModulesProxy.js"],"names":["NativeModules","NativeProxy","ExpoNativeModuleProxy","modulesConstantsKey","exportedMethodsKey","NativeModulesProxy","Object","keys","forEach","moduleName","methodInfo","name","args","key","argumentsCount","length","Error","callMethod","addListener","EXReactNativeEventEmitter","addProxiedListener","removeListeners","removeProxiedListeners","console","warn","module","exports"],"mappings":"AAAA,SAASA,aAAT,QAA8B,cAA9B;AAEA,MAAMC,WAAW,GAAGD,aAAa,CAACE,qBAAlC;AACA,MAAMC,mBAAmB,GAAG,kBAA5B;AACA,MAAMC,kBAAkB,GAAG,iBAA3B;AAEA,MAAMC,kBAAkB,GAAG,EAA3B;;AAEA,IAAIJ,WAAJ,EAAiB;AACfK,EAAAA,MAAM,CAACC,IAAP,CAAYN,WAAW,CAACG,kBAAD,CAAvB,EAA6CI,OAA7C,CAAqDC,UAAU,IAAI;AACjEJ,IAAAA,kBAAkB,CAACI,UAAD,CAAlB,GAAiCR,WAAW,CAACE,mBAAD,CAAX,CAAiCM,UAAjC,KAAgD,EAAjF;AACAR,IAAAA,WAAW,CAACG,kBAAD,CAAX,CAAgCK,UAAhC,EAA4CD,OAA5C,CAAoDE,UAAU,IAAI;AAChEL,MAAAA,kBAAkB,CAACI,UAAD,CAAlB,CAA+BC,UAAU,CAACC,IAA1C,IAAkD,OAAO,GAAGC,IAAV,KAAmB;AACnE,cAAM;AAAEC,UAAAA,GAAF;AAAOC,UAAAA;AAAP,YAA0BJ,UAAhC;;AACA,YAAII,cAAc,KAAKF,IAAI,CAACG,MAA5B,EAAoC;AAClC,gBAAM,IAAIC,KAAJ,CAAW,6BAA4BJ,IAAI,CAACG,MAAO,cAAaD,cAAe,sBAA/E,CAAN;AACD;;AACD,eAAO,MAAMb,WAAW,CAACgB,UAAZ,CAAuBR,UAAvB,EAAmCI,GAAnC,EAAwCD,IAAxC,CAAb;AACD,OAND;AAOD,KARD,EAFiE,CAYjE;AACA;AACA;AACA;AACA;;AACAP,IAAAA,kBAAkB,CAACI,UAAD,CAAlB,CAA+BS,WAA/B,GAA6C,CAAC,GAAGN,IAAJ,KAC3CZ,aAAa,CAACmB,yBAAd,CAAwCC,kBAAxC,CAA2DX,UAA3D,EAAuE,GAAGG,IAA1E,CADF;;AAEAP,IAAAA,kBAAkB,CAACI,UAAD,CAAlB,CAA+BY,eAA/B,GAAiD,CAAC,GAAGT,IAAJ,KAC/CZ,aAAa,CAACmB,yBAAd,CAAwCG,sBAAxC,CAA+Db,UAA/D,EAA2E,GAAGG,IAA9E,CADF;AAED,GArBD;AAsBD,CAvBD,MAuBO;AACLW,EAAAA,OAAO,CAACC,IAAR,CACE,mIADF;AAGD;;AAEDC,MAAM,CAACC,OAAP,GAAiBrB,kBAAjB","sourcesContent":["import { NativeModules } from 'react-native';\n\nconst NativeProxy = NativeModules.ExpoNativeModuleProxy;\nconst modulesConstantsKey = \"modulesConstants\";\nconst exportedMethodsKey = \"exportedMethods\";\n\nconst NativeModulesProxy = {};\n\nif (NativeProxy) {\n  Object.keys(NativeProxy[exportedMethodsKey]).forEach(moduleName => {\n    NativeModulesProxy[moduleName] = NativeProxy[modulesConstantsKey][moduleName] || {};\n    NativeProxy[exportedMethodsKey][moduleName].forEach(methodInfo => {\n      NativeModulesProxy[moduleName][methodInfo.name] = async (...args) => {\n        const { key, argumentsCount } = methodInfo;\n        if (argumentsCount !== args.length) {\n          throw new Error(`Arguments count mismatch, ${args.length} provided, ${argumentsCount} have been expected.`);\n        }\n        return await NativeProxy.callMethod(moduleName, key, args);\n      };\n    });\n\n    // These are called by EventEmitter (which is a wrapper for NativeEventEmitter)\n    // only on iOS and they use iOS-specific native module, EXReactNativeEventEmitter.\n    //\n    // On Android only {start,stop}Observing are called on the native module\n    // and these should be exported as Expo methods.\n    NativeModulesProxy[moduleName].addListener = (...args) =>\n      NativeModules.EXReactNativeEventEmitter.addProxiedListener(moduleName, ...args);\n    NativeModulesProxy[moduleName].removeListeners = (...args) =>\n      NativeModules.EXReactNativeEventEmitter.removeProxiedListeners(moduleName, ...args);\n  });\n} else {\n  console.warn(\n    \"No native NativeModulesProxy found among NativeModules, are you sure the expo-react-native-adapter's modules are linked properly?\"\n  );\n}\n\nmodule.exports = NativeModulesProxy;\n"]},"metadata":{},"sourceType":"module"}