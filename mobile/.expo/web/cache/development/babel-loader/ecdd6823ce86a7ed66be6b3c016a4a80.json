{"ast":null,"code":"import './timer/polyfillNextTick';\nimport zipObject from 'lodash.zipobject';\nimport { NativeModules, Platform } from 'react-native';\nimport customOpenDatabase from '@expo/websql/custom';\nconst {\n  ExponentSQLite\n} = NativeModules;\n\nclass SQLiteDatabase {\n  constructor(name) {\n    this._closed = false;\n    this._name = name;\n  }\n\n  exec(queries, readOnly, callback) {\n    if (this._closed) {\n      throw new Error(`The SQLite database is closed`);\n    }\n\n    ExponentSQLite.exec(this._name, queries.map(_serializeQuery), readOnly).then(nativeResultSets => {\n      callback(null, nativeResultSets.map(_deserializeResultSet));\n    }, error => {\n      // TODO: make the native API consistently reject with an error, not a string or other type\n      callback(error instanceof Error ? error : new Error(error));\n    });\n  }\n\n  close() {\n    this._closed = true;\n    ExponentSQLite.close(this._name);\n  }\n\n}\n\nfunction _serializeQuery(query) {\n  return [query.sql, Platform.OS === 'android' ? query.args.map(_escapeBlob) : query.args];\n}\n\nfunction _deserializeResultSet(nativeResult) {\n  let [errorMessage, insertId, rowsAffected, columns, rows] = nativeResult; // TODO: send more structured error information from the native module so we can better construct\n  // a SQLException object\n\n  if (errorMessage !== null) {\n    return {\n      error: new Error(errorMessage)\n    };\n  }\n\n  return {\n    insertId,\n    rowsAffected,\n    rows: rows.map(row => zipObject(columns, row))\n  };\n}\n\nfunction _escapeBlob(data) {\n  if (typeof data === 'string') {\n    /* eslint-disable no-control-regex */\n    return data.replace(/\\u0002/g, '\\u0002\\u0002').replace(/\\u0001/g, '\\u0001\\u0002').replace(/\\u0000/g, '\\u0001\\u0001');\n    /* eslint-enable no-control-regex */\n  } else {\n    return data;\n  }\n}\n\nconst _openExpoSQLiteDatabase = customOpenDatabase(SQLiteDatabase);\n\nexport function openDatabase(name, version = '1.0', description = name, size = 1, callback) {\n  if (name === undefined) {\n    throw new TypeError(`The database name must not be undefined`);\n  }\n\n  return _openExpoSQLiteDatabase(name, version, description, size, callback);\n}\nexport default {\n  openDatabase\n};","map":{"version":3,"sources":["../src/SQLite.ts"],"names":[],"mappings":"AAAA,OAAO,0BAAP;AAEA,OAAO,SAAP,MAAsB,kBAAtB;AACA,SAAS,aAAT,EAAwB,QAAxB,QAAwC,cAAxC;AACA,OAAO,kBAAP,MAA+B,qBAA/B;AAEA,MAAM;AAAE,EAAA;AAAF,IAAqB,aAA3B;;AAcA,MAAM,cAAN,CAAoB;AAIlB,EAAA,WAAA,CAAY,IAAZ,EAAwB;AAFxB,SAAA,OAAA,GAAmB,KAAnB;AAGE,SAAK,KAAL,GAAa,IAAb;AACD;;AAED,EAAA,IAAI,CAAC,OAAD,EAA2B,QAA3B,EAA8C,QAA9C,EAAsE;AACxE,QAAI,KAAK,OAAT,EAAkB;AAChB,YAAM,IAAI,KAAJ,CAAU,+BAAV,CAAN;AACD;;AAED,IAAA,cAAc,CAAC,IAAf,CAAoB,KAAK,KAAzB,EAAgC,OAAO,CAAC,GAAR,CAAY,eAAZ,CAAhC,EAA8D,QAA9D,EAAwE,IAAxE,CACE,gBAAgB,IAAG;AACjB,MAAA,QAAQ,CAAC,IAAD,EAAO,gBAAgB,CAAC,GAAjB,CAAqB,qBAArB,CAAP,CAAR;AACD,KAHH,EAIE,KAAK,IAAG;AACN;AACA,MAAA,QAAQ,CAAC,KAAK,YAAY,KAAjB,GAAyB,KAAzB,GAAiC,IAAI,KAAJ,CAAU,KAAV,CAAlC,CAAR;AACD,KAPH;AASD;;AAED,EAAA,KAAK,GAAA;AACH,SAAK,OAAL,GAAe,IAAf;AACA,IAAA,cAAc,CAAC,KAAf,CAAqB,KAAK,KAA1B;AACD;;AA3BiB;;AA8BpB,SAAS,eAAT,CAAyB,KAAzB,EAA6C;AAC3C,SAAO,CAAC,KAAK,CAAC,GAAP,EAAY,QAAQ,CAAC,EAAT,KAAgB,SAAhB,GAA4B,KAAK,CAAC,IAAN,CAAW,GAAX,CAAe,WAAf,CAA5B,GAA0D,KAAK,CAAC,IAA5E,CAAP;AACD;;AAED,SAAS,qBAAT,CAA+B,YAA/B,EAA2C;AACzC,MAAI,CAAC,YAAD,EAAe,QAAf,EAAyB,YAAzB,EAAuC,OAAvC,EAAgD,IAAhD,IAAwD,YAA5D,CADyC,CAEzC;AACA;;AACA,MAAI,YAAY,KAAK,IAArB,EAA2B;AACzB,WAAO;AAAE,MAAA,KAAK,EAAE,IAAI,KAAJ,CAAU,YAAV;AAAT,KAAP;AACD;;AAED,SAAO;AACL,IAAA,QADK;AAEL,IAAA,YAFK;AAGL,IAAA,IAAI,EAAE,IAAI,CAAC,GAAL,CAAS,GAAG,IAAI,SAAS,CAAC,OAAD,EAAU,GAAV,CAAzB;AAHD,GAAP;AAKD;;AAED,SAAS,WAAT,CAAwB,IAAxB,EAA+B;AAC7B,MAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC5B;AACA,WAAO,IAAI,CACR,OADI,CACI,SADJ,EACe,cADf,EAEJ,OAFI,CAEI,SAFJ,EAEe,cAFf,EAGJ,OAHI,CAGI,SAHJ,EAGe,cAHf,CAAP;AAIA;AACD,GAPD,MAOO;AACL,WAAO,IAAP;AACD;AACF;;AAED,MAAM,uBAAuB,GAAG,kBAAkB,CAAC,cAAD,CAAlD;;AAEA,OAAM,SAAU,YAAV,CACJ,IADI,EAEJ,OAAA,GAAkB,KAFd,EAGJ,WAAA,GAAsB,IAHlB,EAIJ,IAAA,GAAe,CAJX,EAKJ,QALI,EAKmC;AAEvC,MAAI,IAAI,KAAK,SAAb,EAAwB;AACtB,UAAM,IAAI,SAAJ,CAAc,yCAAd,CAAN;AACD;;AACD,SAAO,uBAAuB,CAAC,IAAD,EAAO,OAAP,EAAgB,WAAhB,EAA6B,IAA7B,EAAmC,QAAnC,CAA9B;AACD;AAID,eAAe;AACb,EAAA;AADa,CAAf","sourcesContent":["import './timer/polyfillNextTick';\n\nimport zipObject from 'lodash.zipobject';\nimport { NativeModules, Platform } from 'react-native';\nimport customOpenDatabase from '@expo/websql/custom';\n\nconst { ExponentSQLite } = NativeModules;\n\ntype InternalQuery = { sql: string; args: unknown[] };\n\ntype InternalResultSet =\n  | { error: Error }\n  | {\n      insertId?: number;\n      rowsAffected: number;\n      rows: Array<{ [column: string]: any }>;\n    };\n\nexport type SQLiteCallback = (error?: Error | null, resultSet?: InternalResultSet) => void;\n\nclass SQLiteDatabase {\n  _name: string;\n  _closed: boolean = false;\n\n  constructor(name: string) {\n    this._name = name;\n  }\n\n  exec(queries: InternalQuery[], readOnly: boolean, callback: SQLiteCallback): void {\n    if (this._closed) {\n      throw new Error(`The SQLite database is closed`);\n    }\n\n    ExponentSQLite.exec(this._name, queries.map(_serializeQuery), readOnly).then(\n      nativeResultSets => {\n        callback(null, nativeResultSets.map(_deserializeResultSet));\n      },\n      error => {\n        // TODO: make the native API consistently reject with an error, not a string or other type\n        callback(error instanceof Error ? error : new Error(error));\n      }\n    );\n  }\n\n  close() {\n    this._closed = true;\n    ExponentSQLite.close(this._name);\n  }\n}\n\nfunction _serializeQuery(query: InternalQuery): [string, unknown[]] {\n  return [query.sql, Platform.OS === 'android' ? query.args.map(_escapeBlob) : query.args];\n}\n\nfunction _deserializeResultSet(nativeResult): InternalResultSet {\n  let [errorMessage, insertId, rowsAffected, columns, rows] = nativeResult;\n  // TODO: send more structured error information from the native module so we can better construct\n  // a SQLException object\n  if (errorMessage !== null) {\n    return { error: new Error(errorMessage) };\n  }\n\n  return {\n    insertId,\n    rowsAffected,\n    rows: rows.map(row => zipObject(columns, row)),\n  };\n}\n\nfunction _escapeBlob<T>(data: T): T {\n  if (typeof data === 'string') {\n    /* eslint-disable no-control-regex */\n    return data\n      .replace(/\\u0002/g, '\\u0002\\u0002')\n      .replace(/\\u0001/g, '\\u0001\\u0002')\n      .replace(/\\u0000/g, '\\u0001\\u0001') as any;\n    /* eslint-enable no-control-regex */\n  } else {\n    return data;\n  }\n}\n\nconst _openExpoSQLiteDatabase = customOpenDatabase(SQLiteDatabase);\n\nexport function openDatabase(\n  name: string,\n  version: string = '1.0',\n  description: string = name,\n  size: number = 1,\n  callback?: (db: WebSQLDatabase) => void\n): WebSQLDatabase {\n  if (name === undefined) {\n    throw new TypeError(`The database name must not be undefined`);\n  }\n  return _openExpoSQLiteDatabase(name, version, description, size, callback);\n}\n\ntype WebSQLDatabase = unknown;\n\nexport default {\n  openDatabase,\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}