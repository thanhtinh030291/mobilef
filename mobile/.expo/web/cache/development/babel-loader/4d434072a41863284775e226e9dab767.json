{"ast":null,"code":"import { Asset } from 'expo-asset';\nexport const _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS = 500;\nexport const _DEFAULT_INITIAL_PLAYBACK_STATUS = {\n  positionMillis: 0,\n  progressUpdateIntervalMillis: _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  shouldPlay: false,\n  rate: 1.0,\n  shouldCorrectPitch: false,\n  volume: 1.0,\n  isMuted: false,\n  isLooping: false\n};\nexport function getNativeSourceFromSource(source) {\n  let uri = null;\n  let overridingExtension = null;\n  let headers;\n\n  let asset = _getAssetFromPlaybackSource(source);\n\n  if (asset != null) {\n    uri = asset.localUri || asset.uri;\n  } else if (source != null && typeof source !== 'number' && 'uri' in source && typeof source.uri === 'string') {\n    uri = source.uri;\n  }\n\n  if (uri == null) {\n    return null;\n  }\n\n  if (source != null && typeof source !== 'number' && 'overrideFileExtensionAndroid' in source && typeof source.overrideFileExtensionAndroid === 'string') {\n    overridingExtension = source.overrideFileExtensionAndroid;\n  }\n\n  if (source != null && typeof source !== 'number' && 'headers' in source && typeof source.headers === 'object') {\n    headers = source.headers;\n  }\n\n  return {\n    uri,\n    overridingExtension,\n    headers\n  };\n}\n\nfunction _getAssetFromPlaybackSource(source) {\n  if (source == null) {\n    return null;\n  }\n\n  let asset = null;\n\n  if (typeof source === 'number') {\n    asset = Asset.fromModule(source);\n  } else if (source instanceof Asset) {\n    asset = source;\n  }\n\n  return asset;\n}\n\nexport function assertStatusValuesInBounds(status) {\n  if (typeof status.rate === 'number' && (status.rate < 0 || status.rate > 32)) {\n    throw new RangeError('Rate value must be between 0.0 and 32.0');\n  }\n\n  if (typeof status.volume === 'number' && (status.volume < 0 || status.volume > 1)) {\n    throw new RangeError('Volume value must be between 0.0 and 1.0');\n  }\n}\nexport async function getNativeSourceAndFullInitialStatusForLoadAsync(source, initialStatus, downloadFirst) {\n  // Download first if necessary.\n  let asset = _getAssetFromPlaybackSource(source);\n\n  if (downloadFirst && asset) {\n    // TODO we can download remote uri too once @nikki93 has integrated this into Asset\n    await asset.downloadAsync();\n  } // Get the native source\n\n\n  const nativeSource = getNativeSourceFromSource(source);\n\n  if (nativeSource === null) {\n    throw new Error(`Cannot load an AV asset from a null playback source`);\n  } // Get the full initial status\n\n\n  const fullInitialStatus = initialStatus == null ? _DEFAULT_INITIAL_PLAYBACK_STATUS : { ..._DEFAULT_INITIAL_PLAYBACK_STATUS,\n    ...initialStatus\n  };\n  assertStatusValuesInBounds(fullInitialStatus);\n  return {\n    nativeSource,\n    fullInitialStatus\n  };\n}\nexport function getUnloadedStatus(error = null) {\n  return {\n    isLoaded: false,\n    ...(error ? {\n      error\n    } : null)\n  };\n}\n/**\n * A mixin that defines common playback methods for A/V classes so they implement the `Playback`\n * interface\n */\n\nexport const PlaybackMixin = {\n  async playAsync() {\n    return this.setStatusAsync({\n      shouldPlay: true\n    });\n  },\n\n  async playFromPositionAsync(positionMillis, tolerances = {}) {\n    return this.setStatusAsync({\n      positionMillis,\n      shouldPlay: true,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore\n    });\n  },\n\n  async pauseAsync() {\n    return this.setStatusAsync({\n      shouldPlay: false\n    });\n  },\n\n  async stopAsync() {\n    return this.setStatusAsync({\n      positionMillis: 0,\n      shouldPlay: false\n    });\n  },\n\n  async setPositionAsync(positionMillis, tolerances = {}) {\n    return this.setStatusAsync({\n      positionMillis,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore\n    });\n  },\n\n  async setRateAsync(rate, shouldCorrectPitch) {\n    return this.setStatusAsync({\n      rate,\n      shouldCorrectPitch\n    });\n  },\n\n  async setVolumeAsync(volume) {\n    return this.setStatusAsync({\n      volume\n    });\n  },\n\n  async setIsMutedAsync(isMuted) {\n    return this.setStatusAsync({\n      isMuted\n    });\n  },\n\n  async setIsLoopingAsync(isLooping) {\n    return this.setStatusAsync({\n      isLooping\n    });\n  },\n\n  async setProgressUpdateIntervalAsync(progressUpdateIntervalMillis) {\n    return this.setStatusAsync({\n      progressUpdateIntervalMillis\n    });\n  }\n\n};","map":{"version":3,"sources":["../../src/av/AV.ts"],"names":[],"mappings":"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","sourcesContent":["import { Asset } from 'expo-asset';\n\n// TODO add:\n//  disableFocusOnAndroid\n//  audio routes (at least did become noisy on android)\n//  pan\n//  pitch\n//  API to explicitly request audio focus / session\n//  API to select stream type on Android\n//  subtitles API\n\nexport type PlaybackSource =\n  | number\n  | { uri: string; overrideFileExtensionAndroid?: string; headers?: { [fieldName: string]: string } }\n  | Asset;\nexport type PlaybackNativeSource = { uri: string; overridingExtension?: string | null; headers?: { [fieldName: string]: string } };\n\nexport type PlaybackStatus =\n  | {\n      isLoaded: false;\n      androidImplementation?: string;\n      error?: string; // populated exactly once when an error forces the object to unload\n    }\n  | {\n      isLoaded: true;\n      androidImplementation?: string;\n\n      uri: string;\n\n      progressUpdateIntervalMillis: number;\n      durationMillis?: number;\n      positionMillis: number;\n      playableDurationMillis?: number;\n      seekMillisToleranceBefore?: number;\n      seekMillisToleranceAfter?: number;\n\n      shouldPlay: boolean;\n      isPlaying: boolean;\n      isBuffering: boolean;\n\n      rate: number;\n      shouldCorrectPitch: boolean;\n      volume: number;\n      isMuted: boolean;\n      isLooping: boolean;\n\n      didJustFinish: boolean; // true exactly once when the track plays to finish\n    };\n\nexport type PlaybackStatusToSet = {\n  androidImplementation?: string;\n  progressUpdateIntervalMillis?: number;\n  positionMillis?: number;\n  seekMillisToleranceBefore?: number;\n  seekMillisToleranceAfter?: number;\n  shouldPlay?: boolean;\n  rate?: number;\n  shouldCorrectPitch?: boolean;\n  volume?: number;\n  isMuted?: boolean;\n  isLooping?: boolean;\n};\n\nexport const _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS: number = 500;\nexport const _DEFAULT_INITIAL_PLAYBACK_STATUS: PlaybackStatusToSet = {\n  positionMillis: 0,\n  progressUpdateIntervalMillis: _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  shouldPlay: false,\n  rate: 1.0,\n  shouldCorrectPitch: false,\n  volume: 1.0,\n  isMuted: false,\n  isLooping: false,\n};\n\nexport function getNativeSourceFromSource(\n  source: PlaybackSource | null\n): PlaybackNativeSource | null {\n  let uri: string | null = null;\n  let overridingExtension: string | null = null;\n  let headers: { [fieldName: string]: string } | undefined;\n\n  let asset: Asset | null = _getAssetFromPlaybackSource(source);\n  if (asset != null) {\n    uri = asset.localUri || asset.uri;\n  } else if (\n    source != null &&\n    typeof source !== 'number' &&\n    'uri' in source &&\n    typeof source.uri === 'string'\n  ) {\n    uri = source.uri;\n  }\n\n  if (uri == null) {\n    return null;\n  }\n\n  if (\n    source != null &&\n    typeof source !== 'number' &&\n    'overrideFileExtensionAndroid' in source &&\n    typeof source.overrideFileExtensionAndroid === 'string'\n  ) {\n    overridingExtension = source.overrideFileExtensionAndroid;\n  }\n\n  if (source != null && typeof source !== 'number' && 'headers' in source && typeof source.headers === 'object') {\n    headers = source.headers;\n  }\n  return { uri, overridingExtension, headers };\n}\n\nfunction _getAssetFromPlaybackSource(source: PlaybackSource | null): Asset | null {\n  if (source == null) {\n    return null;\n  }\n\n  let asset: Asset | null = null;\n  if (typeof source === 'number') {\n    asset = Asset.fromModule(source);\n  } else if (source instanceof Asset) {\n    asset = source;\n  }\n  return asset;\n}\n\nexport function assertStatusValuesInBounds(status: PlaybackStatusToSet): void {\n  if (typeof status.rate === 'number' && (status.rate < 0 || status.rate > 32)) {\n    throw new RangeError('Rate value must be between 0.0 and 32.0');\n  }\n  if (typeof status.volume === 'number' && (status.volume < 0 || status.volume > 1)) {\n    throw new RangeError('Volume value must be between 0.0 and 1.0');\n  }\n}\n\nexport async function getNativeSourceAndFullInitialStatusForLoadAsync(\n  source: PlaybackSource | null,\n  initialStatus: PlaybackStatusToSet | null,\n  downloadFirst: boolean\n): Promise<{\n  nativeSource: PlaybackNativeSource;\n  fullInitialStatus: PlaybackStatusToSet;\n}> {\n  // Download first if necessary.\n  let asset = _getAssetFromPlaybackSource(source);\n  if (downloadFirst && asset) {\n    // TODO we can download remote uri too once @nikki93 has integrated this into Asset\n    await asset.downloadAsync();\n  }\n\n  // Get the native source\n  const nativeSource: PlaybackNativeSource | null = getNativeSourceFromSource(source);\n\n  if (nativeSource === null) {\n    throw new Error(`Cannot load an AV asset from a null playback source`);\n  }\n\n  // Get the full initial status\n  const fullInitialStatus: PlaybackStatusToSet =\n    initialStatus == null\n      ? _DEFAULT_INITIAL_PLAYBACK_STATUS\n      : {\n          ..._DEFAULT_INITIAL_PLAYBACK_STATUS,\n          ...initialStatus,\n        };\n  assertStatusValuesInBounds(fullInitialStatus);\n\n  return { nativeSource, fullInitialStatus };\n}\n\nexport function getUnloadedStatus(error: string | null = null): PlaybackStatus {\n  return {\n    isLoaded: false,\n    ...(error ? { error } : null),\n  };\n}\n\nexport interface AV {\n  setStatusAsync(status: PlaybackStatusToSet): Promise<PlaybackStatus>;\n}\n\nexport interface Playback extends AV {\n  playAsync(): Promise<PlaybackStatus>;\n  playFromPositionAsync(\n    positionMillis: number,\n    tolerances?: { toleranceMillisBefore?: number; toleranceMillisAfter?: number }\n  ): Promise<PlaybackStatus>;\n  pauseAsync(): Promise<PlaybackStatus>;\n  stopAsync(): Promise<PlaybackStatus>;\n  setPositionAsync(\n    positionMillis: number,\n    tolerances?: { toleranceMillisBefore?: number; toleranceMillisAfter?: number }\n  ): Promise<PlaybackStatus>;\n  setRateAsync(rate: number, shouldCorrectPitch: boolean): Promise<PlaybackStatus>;\n  setVolumeAsync(volume: number): Promise<PlaybackStatus>;\n  setIsMutedAsync(isMuted: boolean): Promise<PlaybackStatus>;\n  setIsLoopingAsync(isLooping: boolean): Promise<PlaybackStatus>;\n  setProgressUpdateIntervalAsync(progressUpdateIntervalMillis: number): Promise<PlaybackStatus>;\n}\n\n/**\n * A mixin that defines common playback methods for A/V classes so they implement the `Playback`\n * interface\n */\nexport const PlaybackMixin = {\n  async playAsync(): Promise<PlaybackStatus> {\n    return ((this as any) as AV).setStatusAsync({ shouldPlay: true });\n  },\n\n  async playFromPositionAsync(\n    positionMillis: number,\n    tolerances: { toleranceMillisBefore?: number; toleranceMillisAfter?: number } = {}\n  ): Promise<PlaybackStatus> {\n    return ((this as any) as AV).setStatusAsync({\n      positionMillis,\n      shouldPlay: true,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n    });\n  },\n\n  async pauseAsync(): Promise<PlaybackStatus> {\n    return ((this as any) as AV).setStatusAsync({ shouldPlay: false });\n  },\n\n  async stopAsync(): Promise<PlaybackStatus> {\n    return ((this as any) as AV).setStatusAsync({ positionMillis: 0, shouldPlay: false });\n  },\n\n  async setPositionAsync(\n    positionMillis: number,\n    tolerances: { toleranceMillisBefore?: number; toleranceMillisAfter?: number } = {}\n  ): Promise<PlaybackStatus> {\n    return ((this as any) as AV).setStatusAsync({\n      positionMillis,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n    });\n  },\n\n  async setRateAsync(rate: number, shouldCorrectPitch: boolean): Promise<PlaybackStatus> {\n    return ((this as any) as AV).setStatusAsync({ rate, shouldCorrectPitch });\n  },\n\n  async setVolumeAsync(volume: number): Promise<PlaybackStatus> {\n    return ((this as any) as AV).setStatusAsync({ volume });\n  },\n\n  async setIsMutedAsync(isMuted: boolean): Promise<PlaybackStatus> {\n    return ((this as any) as AV).setStatusAsync({ isMuted });\n  },\n\n  async setIsLoopingAsync(isLooping: boolean): Promise<PlaybackStatus> {\n    return ((this as any) as AV).setStatusAsync({ isLooping });\n  },\n\n  async setProgressUpdateIntervalAsync(\n    progressUpdateIntervalMillis: number\n  ): Promise<PlaybackStatus> {\n    return ((this as any) as AV).setStatusAsync({ progressUpdateIntervalMillis });\n  },\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}